Robots(2)

1 プログラムの効率（計算量）
  今回作成した robots プログラムの効率について考える．一般にプログラムの効率は，

    ・実行時間
    ・メモリ使用量

によって評価される．当然ながら，実行時間が短くて，メモリをあまり使わないプログラムほど効率的である．
  実行時間やメモリ使用量を，単に作成したプログラムを実測して得た x 秒，y バイトという値で議論するのは，あまりうまくない．まず，実測値は利用する計算機や言語処理系に依存するため，ある問題をある計算機上で 3 秒で計算するプログラムが，別の計算機で 4 秒かかるプログラムより優れているとは決められない．
  さらに重要なのは，たいていのプログラムでは，問題の大きさによって実行時間やメモリ使用量が変化することである．そして，プログラムの性質を考えるときには，問題のサイズをどんどん大きくしていったときに，実行時間やメモリ使用量がどのように増大するかに関心がある．
  たとえば今回の robots では，ロボットの移動と衝突の処理の手間は，おそらくロボットの数に依存している．ロボットの数を n とするとき，ある計算機上での処理時間が 10n + 5 秒であるプログラム A は，別の（または同じ）計算機上での処理時間が 2n^2 + n + 1 秒であるプログラム B よりも効率がよいと考えるべきである（ロボット台数が 4 台以下のときには，A は B より遅いが）．

2 オーダ
  特定の計算機環境や問題サイズによらず，プログラムの効率を一般的に表現するのに便利な「オーダ」（Order）の考え方を紹介する．
  ある正の実数 c と自然数 n0 が存在して，n0 以上のどんな自然数 n に対しても f(n) ≦ cg(n) が成り立つとき，

    f(n) = O(g(n))

と表し，「f(n) のオーダはg(n)である」とか「f(n)はたかだかg(n)のオーダである」などという．
  上述の「プログラム A の処理時間」を a(n) とすれば，

    a(n) = 10n + 5 = O(n)

である（c = 15 とすれば，1 以上の n に対して 10n + 5 ≦ cn）．またプログラム B の処理時間を b(n) とすれば，

    b(n) = 2n^2 + n + 1 = O(n^2)

である（c = 3とすれば，1 以上の n に対して 2n^2 + n + 1 ≦ cn^2）．
  O 記法を用いると，「二つのプログラムのどちらが効率的であるか」を明快に表すことができる（手間が O(n) であるプログラム A は O(n^2) であるプログラム B よりも効率的である，など）．

※上の例ではたまたま n0 が小さな値であったが，定数でありさえすれば，100 万でも 100兆でも（理論上は）かまわない．

※上の例から推測できるとおり，

    f(n) = ak n^k + ak-1 n^(k-1) + ...

のような多項式のオーダは，最大次数の項だけに注目して

    f(n) = O(n^k)

で表せる．したがって，単純な繰返しによって構成されているプログラムならば，一番深い繰返しの段数を数えるだけで，計算時間のオーダを求められる．
  たとえば，

    for (i = 0;i < n;i++){
        for (j = i;j < n;j++){
          <処理>
        }
    }

の <処理> を実行する回数は，

    1 + 2 + 3 + … + n = n(n + 1) / 2 = O(n^2)

である．ただし <処理> 部分の手間は i や j に依存しないものとする．

※10n + 5 = O(n^3) も間違いではないので，「オーダの小さいプログラムが，より効率的」というのは，厳密には正しくない．逆にプログラムの効率を議論するためには，なるべく正確なオーダを用いる必要があるといえる．
  このあたりのちゃんとしたお話は，「アルゴリズム」や「計算量」などの分野で扱われている．

3 レポート課題（最終レポートに含めること）
  自分の robots プログラムの

    プレイヤ移動
    ロボット移動
    衝突

の各処理時間を O 記法で表しなさい．また，プログラムが用いるデータ領域の大きさも，同様に O 記法で表しなさい．ただし，プログラムによっては，ロボットの台数ではなくフィールドの大きさに依存しているもの，あるいはロボット台数 n とフィールドの大きさ m の両方に依存しているものもあるだろう．したがって処理時間やデータ量は O(n)，O(m) ，O(m + n)，O(mn^2)  などと表すことになる．

※robots においては n < m なので，O(m + n) は結局 O(m) になる．
※プログラムの作り方によっては，プレイヤ移動，ロボット移動，衝突に分けられないかもしれない．その場合，相当する処理について計算の手間を求めなさい．

※もしかしたら，計算の手間は，O(log(n)) や O(e^n) のような，式になるかもしれない．大まかな話としては，

  O(log(n))

は速いアルゴリズムである．

  O(n^a))  a は定数

は「多項式オーダ」などといわれ，「現実的な」手間であると見なされる．実際のプログラムにおいては， a = 1 ならまずまずの手間といえることが多い．a = 2 では n の大きさに注意が必要になり，a = 3 くらいが実用の限界である．
  多項式オーダよりも手間のかかるプログラムは，実際上ほとんど使いものにならない．たとえば，

  O(a^n)  a は 1 より大きな定数（「指数オーダ」などという）
  O(n!)
  O(n^n)

の手間がかかるアルゴリズムは，n = 5 くらいならさほどの大きさではないが， n = 10 程度になるともう手に負えない場合が多い．
